# 고민해볼 것

### Setter는 왜 지양해야하는가?
Setter는 객체지향 원칙을 깰 위험성이 크다.

객체는 일관성을 보장받아야 하는데 도메인 규칙이 적용되는 범위 밖에서 Setter를 사용할 수 있으면 규칙과 관계 없이 정보가 변할 수 있다.

ex. 닉네임 글자수 제한을 설정해뒀는데 Setter를 만들어서 public으로 어디서든 필드에 접근이 가능하면 의도치 않은 곳에서 닉네임이 변경될 수 있다. 

단순히 입력받은 값으로 필드를 갱신하는 setter보다는 의미 있는 메서드로 상태를 변경하도록 한다. (규칙을 체크하고 맞으면 값을 갱신하도록 한다거나)

### 기본 생성자의 접근 지정자를 제한하는 이유는?
마찬가지로 객체지향의 원칙(은닉성, 캡슐화 등)을 지키기 위함이다. **의도하지 않은** 인스턴스 생성을 막아 객체의 일관성을 유지하고, 불필요한 외부 접근을 막는다.

`public`으로 된 생성자가 의도치 않게 생성되는 경우 필수 데이터가 누락된 상태에서 불완전한 상태의 객체가 생성될 수도 있다.


기본 생성자를 protected로 제한하여 외부에서 사용하지 못하게 한다. 
JPA 내부적으로만 기본 생성자를 호출하여 안전한 엔티티 초기화를 보장할 수 있다.


### 객체 생성 시 생성자, 팩토리 메서드, 빌더 패턴 각각의 정의와 장단점


#### 생성자
생성자는 위에서 다룬 것 처럼 접근 제한을 통해 필수 값을 보장 받을 수 있다. 파라미터가 많아지면 읽기 어렵다는 문제가 있다.


#### 팩토리 메서드
정적 팩토리 메서드라고도 불리며, 생성자를 바로 사용하지 않고 생성자를 접근 제한자로 제한한 상태에서 public으로 공개된 메서드를 만들어 내부의 생성자를 사용하는 방식으로 객체를 생성하도록 하는 메서드이다. 

생성자는 이름이 고정이지만 팩토리 메서드는 이름을 자유롭게 부여하여 의도를 표현하기 좋다. 
ex. `Member.of(name)`

하지만 마찬가지로 메서드 파라미터를 받아 이루어지므로 파라미터가 많아지면 가독성이 문제

#### 빌더
**필수 값과 선택 값을 구분**하고 메서드 체이닝을 통해 객체를 단게적으로 생성하는 방식이다.


체이닝 메서드를 사용하기 때문에 사용되는 필드가 많아도 가독성이 좋다.

다만 가독성은 해결되어도 코드 자체는 다소 길어질 수 있고 빌더 클래스를 추가로 생성해야해서 오버헤드가 발생할 수 있다.